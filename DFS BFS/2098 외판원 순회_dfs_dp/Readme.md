# 외판원 문제



1. dfs로 모든 경로를 찾는다.

2. dfs에 dp와 비트마스킹을 적용한다.

3. `dp[현재도시][방문한도시]`를 뜻하며 dp 값은 현재 도시에서 최종 도시(다시 돌아가므로 시작도시)로 가는 최소비용이다.

4. 방문한 도시는 비트마스킹을 사용한다.

   ​														`dp[0][0001]`(dfs(0,1)) = 시작.

   ​								`dp[1][0011]`(dfs(1,3)) 		`dp[2][0101]` 	`dp[3][1001]`

   ​						`dp[2][0111]`

   ​					`dp[3][1111]` = leaf

5. leaf에서 모든 경로를 돌았으니 3번 도시에서 0 도시로 돌아가는 값 `W[3][0]`을 리턴한다.

6. `dp[2][0111]`에서 `int temp = min(ref ,dfs(3,0111)+W[2][3])`로 업데이트한다. 현재 dfs(3,0111)은 3번에서 구했던 `W[3][0]`

7. 게속 올라가면서 `dp[0][0001]`에서 `int temp = min(ref, dfs(1,0001) + W[0][1])`을 끝남.

8. 그럼 `dp[0][0001]` 노드에 있는 ref를 다른 분기인 `dp[2][0101]`도 3번부터 5번까지 반복.

9. 모든 경우의 수를 다 돌고 나서 `dp[0][0001]` dfs에서 리턴하는 값이 경로를 도는 최소 비용.

