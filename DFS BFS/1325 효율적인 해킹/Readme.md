## [1324. 효율적인 해킹](https://www.acmicpc.net/problem/1325)

## 문제접근

- A가 B를 신뢰하는 경우에는 B를 해킹하면 A도 해킹이 가능한 지문에서 단방향 그래프를 생각하였고 단방향으로 여러 대의 컴퓨터가 신뢰를 하므로 인접리스트를 단방향으로 하기 위해서 vector를 사용하였다.
- 단방향으로 연결된 인접리스트에서 DFS를 사용하여 연결된 노드를 모두 방문하면서 DFS는 재귀적으로 실행되므로 한번 DFS함수가 실행될때마다 횟수를 ++계산하여 각 컴퓨터마다 체크를 해야한다.
- 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순으로 출력하여야 하므로 정렬하는 것을 생각하였다.





## 문제점

- 문제점으로 vector에 들어간 값에 대해서 우선 연결된 횟수에 대해서 내림차순으로 정렬을 한 후에 다시 한번 컴퓨터 번호대로 오름차순으로 정렬을 했어야 했다. 시간 복잡도가 많이 올라갈 것으로 예상하였다. N이 10000개까지 가능하므로...



### 문제해결 

- 정렬에 대해서는 deque<pair<int,int>>를 사용하였다. deque를 사용한 이유는 처음에는 vector에 단점을 보안한 앞에서도 데이터를 넣을 수 있기 때문에 사용하였는데 직접 알고리즘을 한 결과 굳이 사용할 필요가 없었다. 또한 pair<int,int>를 사용한 이유는 first값에 컴퓨터 번호를 넣고 그에 따른 연결된 컴퓨터 값을 second에 넣기 위해서 이다. 
- deque를 사용안해도 되는 이유는 문제해결 도중에 정렬보다 O(n)으로 이 문제를 해결할 수 있었다. 처음에 pair에 첫번째 값을 넣고 이것보다 큰 값을 한번 쭉 돌면서 찾는다. 찾게 되면 high_score를 갱신한다.
- 최고점을 찾게되면 저 high_score는 처음부터 순차적으로 찾은 것이기에 가장 많이 연결된 가장 낮은 번호이므로 이 번호 이후로 이 값과 같은 값이 있는지 찾으면서 출력만 해주면 해결이된다. 





