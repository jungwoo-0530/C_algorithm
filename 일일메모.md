1월 4주

-  로봇청소기(14503)
-  [2020 KAKAO BLIND RECRUITMENT](https://programmers.co.kr/learn/challenges) - 문자열 압축





토요일날 - https://programmers.co.kr/learn/courses/30/lessons/60059, https://ansohxxn.github.io/programmers/82/ 풀기.

-----------------------------

순서가 있는 큰 수

- 프로그래머스 큰수 만들기(그리디알고리즘)

  - ```c++
    string solution(string number, int k) {
        string answer = "";
    
        int maxIdx = 0;
        int start = 0;
        char max = ' ';
        for(int i = 0; i < number.size() - k; i++){
            
            max = number[start];
            maxIdx = start;
            
            for(int j = start; j <= i+k; j++){
                if(number[j] > max)
                {
                    maxIdx = j;
                    max = number[j];
                }
            }
            answer += max;
            start = maxIdx + 1;
        }
        return answer;
    }
    ```

    

순서가 없는 큰 수(프로그래머스 )



C++

1. Set(기둥과 보 설치)

- 중복 없음.

set은 for(auto a : Set){
}을 사용해서 loop

Set<int>a

a.find(20) ->  a.end()와 같다면 존재하지 않음.

```c++
set<vector<int>> building
  
//set 순회.
for(auto build : building)
{       int x = build[0];
        int y = build[1];
        int a = build[2];
 }

//지우기
vector<int> v
building.erase(v);

//삽입
building.insert(v);

//중복확인.
auto flag = building.insert(v);
if(flag.second == false)
{
  //중복.
}
set<int> b;
//해당 인덱스 선택.
//1번
auto iter = b.begin();
iter++
int temp = *iter;
//2번
for(auto iter : b)
{
  temp = iter;
}


```

vector

2. vector



```c++
/////////////초기화
//1. vector<int> vec = { -1,-1,-1 }; 000으로 초기화 3개.
vector<int> vec(3);

//2. -1 -1 -1로 초기화
vector<int> vec(3,-1);
//3. 2차원 벡터
vector<vector<int>> vec(3, vector<int>(3,-1));



//
vector<int> vec = {1,2,3,4};
//2차원 배열로 [3][4]
vector<int>pred[3] = { {1,2,3,4}, {5,6,7,8}, {9,10,11,12} };

/////////벡터 복사 방법
//1
vector<int> a;
vector<int> b = a;

//2
vector<int> a;
vector<int> b;
a = b;

//3
vector<int>a;
vector<int>b(a.begin(), a.end());

```



```c++
vector<vector<pair<bool,bool>>>map(n, vector<pair<bool, bool> >(n, make_pair(false,false)));

map[y][x].first = false;
```

```c++
vector<vector<int> > answer;
//지우기
if(answer[j][0] == x && answer[j][1] == y && answer[j][2] == 1)
                    {
                        
                        answer.erase(answer.begin()+j);
                    
               
                    }

//지우기


//정렬
sort(answer.begin(), answer.end());

//삽입
//1.
vector<int>temp{x,y,build_frame[i][2]};
answer.push_back(temp);

//2.

```



3. map

- 중복x
- 기본적으로 key에 대해서 오름차순(작은 수가 제일 앞으로 옴)
- key 기준으로 내림차순으로 하고 싶다면 map선언시  greater<int>
- value 기준으로 정렬하고 싶다면 https://unluckyjung.github.io/cpp/2020/05/07/Sort_map_by_value/
- insert로 중복된 key값을 넣으면 무시되고
- [] 로 중복된 key값을 넣으면 값이 대체된다.
- Binary Search Tree로 탐색 시간 복잡도는 O(log n)

```c++
map<key,value> a;

//초기화
//1. 한개.
map<string, int>c = {{"jungwoo", 1}};
//2. 두개.
map<string, int>c = {{"jungwoo", 1}, {"sunwoo", 2}};


//삽입
a[key] = value;

//순회
for(int i = 0; i < a.size(); i++){
  cout << a[i]; // value 출력.
}

//삽입
//1.
map<key, set<string>>b;
b[key].insert(string);
//2.
map<string, vector<int>>f;
     f["jungwoo"].push_back(1);
     f["jungwoo"].push_back(2);
     f["jung"].push_back(3);
     f["jung"].push_back(4);
     
     for(auto a : f)
     {
          for(auto b : a.second)
          {
               cout << a.first << b << "\n";
          }
     }
//iter의 first(key), second(value)
//map의 value가 vector나 그런 것도 iter.second로 접근 가능.
for(auto iter : a)
{
  cout << "key:" << iter.first << "value:" << iter.second; 
}


```



---------------------------------------------------------------------------

bfs시 한칸이 이동한다?  구조체 사용x

bfs시 여러칸이 이동한다? 또한 여러개를 저장해야할때? 구조체 사용

```c++
Struct Robot{
	int x;
	int y;
	int time;
	int dir;
	Robot(int a, int b, int c, int d)
	{
		x = a;
		y = b;
		time = c;
		dir = d;
	}
}

...
  
  Queue<Robot>q;
q.push(Robot(x,y,time,dir));
```



또한 bfs 할 때, 새로운 좌표에서로 갈 수 있는지 확인하는 check()함수 만들어주기.

```c++
int nDir = (dir + 1) % 4 // 4방향을 90도회전시켜서 방향을 잡음.
//그래서 이 값과 dx,dy를 연동해서 새로운 방향을 인덱스로 이동할 dx dy를 구함.
  int nx = x + dx[nDir];

//또한 4방향에 따라서 visit을 구하고 싶다면.
bool visit[100][100][4] = {false,}로 한다.
```



-------------------------------------

### Prefix Sum(누적합)-https://tech.kakao.com/2022/01/14/2022-kakao-recruitment-round-1/

- x0, x1 … xN까지 수가 있을 때 

  - y0=x0, y1=x0+x1 … yN=x0+x1+…+xN처럼 해당 N까지의 합을 의미합니다.

  - ```
    y0 = x0
    y1 = x0 + x1
    y2 = x0 + x1 + x2
    ...
    yN = x0 + x1 + ... + xN
    ```

  - 매번 요청이 올때마다 미리 구해놓은 sum배열을 이용해 값을 바로 반환합니다.(O(n))

  - ```c++
    #include <cstdio>
    
    #define MAX_N 100001
    #define MAX_M 100001
    
    using namespace std;
    
    int value[MAX_N];
    int sum[MAX_N];
    
    int main(){
    
        int N, M;
    
        scanf("%d %d", &N, &M);
    
        for(int i = 1; i <= N; ++i){
            scanf("%d", &value[i]);
            sum[i] = sum[i-1] + value[i];
        }
    
        while(M--){
            int from, to;
            scanf("%d %d", &from, &to);
            printf("%d\n", sum[to] - sum[from - 1] );
        }
    
    
        return 0;
    }
    ```

    

  - 

### DP(다이나믹 프로그래밍)





----------------------------------------------

### 문자열 자르기

```c++
//인덱스로 자르기.
#include<string>

string a = "0123456";

string temp = a.substr(3,2); // temp = 34

//공백 또는 특수문자 등등으로 자르기.
#include <sstream>
string str = "jung woo";
istringstream ss(str);
string stringBuffer;
while(getline(ss, stringBuffer, ' ')){
  cout << stringBuffer;
}

//이렇게도 가능. 공백으로 자르기.
string a = "10:11 1234 IN";

stringstream ss;

ss.str(a);

string time;
string number;
string status;
ss >> time >> number >> status;
ss.clear();


```



### String to int

```c++
#include<string>
int i = stoi(str);
```





```c++
map<string, int>genresRank;
     map<string, vector<pair<int,int>>> temp;
     
     for(int i = 0; i<genres.size(); i++)
     {
          auto a  = genresRank.find(genres[i]);
          if(a != genresRank.end())//값이 이미 있을떄
          {
               int tem = a->second;
               a->second = tem+plays[i];
          }
          else{
               genresRank[genres[i]] = plays[i];
          }
          
          temp[genres[i]].push_back(make_pair(i, plays[i]));
     }
```



### Map Sort

1. key 기준

- 생성자에서 greater.. 등을 사용.

1. value 기준.

- map을 vector로 변경 후, vector를 sort.

```c++
int main(){
     
     map<string, int> map1;
     map<int, int> map2;
     map<string, map<int,int>> map3;
     
     map1["A"] = 1;
     map1["B"] = 2;
     map1["C"] = 2;
     map1["D"] = 4;
     map1["E"] = 5;
     
     vector<pair<string,int>> vec( map1.begin(), map1.end() );

     sort(vec.begin(), vec.end(), cmp1);
     
     for(auto m1 : vec)
     {
          cout << m1.first << " " << m1.second << endl;
     }
     return 0;
     
     
}
```



cmp함수는 크레센도 처럼 <으로하면 점점 커지는 내림차순, >으로하면 점점 작아지게(오름차순)

```c++
bool cmp1(pair<string, int> a, pair<string, int> b) {

     if(a.second == b.second)
          return a.first > b.first;
     return a.second < b.second;
}
```

second는 내림차순, first는 오름차순(second가 같을때.)

<img src="/Users/jungwoo/Desktop/dev/img/image-20220127042034446.png" alt="image-20220127042034446" style="zoom:50%;" />

```c++
bool cmp1(pair<string, int> a, pair<string, int> b) {

     if(a.second == b.second)
          return a.first < b.first;
     return a.second < b.second;
}
```

second는 내림차순, first는 내림차순(second가 같을때.)

<img src="/Users/jungwoo/Desktop/dev/img/image-20220127042126134.png" alt="image-20220127042126134" style="zoom:50%;" />





정렬전.

```c++
int main(){
     
     
     map<string, map<string,int>> map3;
     
     
     
     map3["A"]["a"] = 3;
     map3["A"]["b"] = 1;
     map3["A"]["c"] = 2;
     map3["B"]["a"] = 2;
     map3["B"]["b"] = 3;
     map3["C"]["a"] = 5;
     map3["D"]["a"] = 46;
     map3["E"]["a"] = 5;
     
     for(auto a : map3)
     {
          cout << a.first <<endl;
          for(auto b : a.second)
          {
               cout << b.first << " : " << b.second << endl;
          }
          cout << endl;
     }
     
     
     
     return 0;
     
     
}
```

<img src="/Users/jungwoo/Desktop/dev/img/image-20220127040816112.png" alt="image-20220127040816112" style="zoom:50%;" />

정렬후.

```c++
     for(auto a : map3)
     {
          cout << a.first <<endl;
          vector<pair<string,int>> vec1(a.second.begin(), a.second.end());
          sort(vec1.begin(), vec1.end(), cmp1);
          for(auto b : vec1)
          {
               cout << b.first << " : " << b.second << endl;
          }
          cout << endl;
     }
```



```c++
bool cmp1(pair<string, int> a, pair<string, int> b) {

     if(a.second == b.second)
          return a.first < b.first;
     return a.second < b.second;
}
```



<img src="/Users/jungwoo/Desktop/dev/img/image-20220127041016144.png" alt="image-20220127041016144" style="zoom:50%;" />



- 참고로 vector를 sort할 때, cmp 함수 대신, greater, less 사용가능.







-----------------------------------------------------------------------------

1. CS공부

2. 스프링 프로젝트
   1. Rest Api
   2. 기본
3. 코테
   1. C++
   2. JAVA?





---------------------------------------------------------------

DP

top-down 방식으로 풀면 재귀함수를 사용하면 될 것 같습니다. 

DP문제에서 보통 top-down방식은 재귀, buttom-up방식은 반복문을 사용합니다.

- 프로그래머스 [정수삼각형](https://programmers.co.kr/learn/courses/30/lessons/43105?language=cpp)

  - <img src="/Users/jungwoo/Desktop/dev/img/image-20220202040914504.png" alt="image-20220202040914504" style="zoom:50%;" />

  - top-down방식으로 재귀를 사용할 수 있아.

  - 위 사진과 같이 작은 삼각형으로 생각하고 자식 노드 중 큰 값을 부모노드와 더해서 계산.

  - ```c++
    return dp[row][col] = dp[row][col] + max(recursive(row+1,col), dfs(row+1,col+1));
    ```

  - 위 코드를 보면 맨 처음 `dp[0][0]`을 찾아야 하므로 아래로 내려가면서 계속 작은 삼각형의 부모노드를 업데이트해야한다.

  - 저 recursive 함수에 다음과 같은 dp알고리즘을 주어서 이미 계산한 것은 계산하지 않도록 한다.

  - `if (dp[row][col] > 0) return dp[row][col];`

  - 즉 프로그램상 계산 순서는 맨 아래 삼각형 4개를 먼저 계산하고 2 7 4 4(부모 노드들)이 dp 배열에 업데이트 된다.



단순 dfs

```
row0col0
row1col0
row2col0
row3col0
row4col0
row4col1
row3col1
row4col1
row4col2
row2col1
row3col1
row4col1
row4col2
row3col2
row4col2
row4col3
row1col1
row2col1
row3col1
row4col1
row4col2
row3col2
row4col2
row4col3
row2col2
row3col2
row4col2
row4col3
row3col3
row4col3
row4col4
```

dp 사용한 것

```
row0col0
row1col0
row2col0
row3col0
row4col0
row5col0
row5col1
row4col1
row5col1
row5col2
row3col1
row4col1
dp : row4col1
row4col2
row5col2
row5col3
row2col1
row3col1
dp : row3col1
row3col2
row4col2
dp : row4col2
row4col3
row5col3
row5col4
row1col1
row2col1
dp : row2col1
row2col2
row3col2
dp : row3col2
row3col3
row4col3
dp : row4col3
row4col4
row5col4
row5col5
```



- <img src="/Users/jungwoo/Desktop/dev/img/image-20220202044537355.png" alt="image-20220202044537355" style="zoom:50%;" />

- 내가 맨 dp없이 한 dfs는 위와 같은 모양으로 계속 더하고 탐색하면서 최고 밑단에서 결과를 도출한다.
- 이렇게 한다면 결과는 같이 나온다. 그러나 표시한 곳에서 8 -> 7 -> 5 -> 2 계산을 한 후, 1 -> 7 -> 5 -> 2라는 중복 적인 계산이 발생한다.
- <img src="/Users/jungwoo/Desktop/dev/img/image-20220202045404617.png" alt="image-20220202045404617" style="zoom:50%;" />
- dp를 사용한다면 1에서 7로 갈때, 계산한 값을 사용하므로 그 밑에 7번 노드에 자식 5, 2를 중복으로 계산을 안해도 된다.

- **두 방식 다 방문하는 노드와 방문하는 순서는 같다.** 그러나 방문을 하더라도 계산을하느냐 안하고 바로 저장된 값을 사용해서 리턴하는 냐는 큰 차이다.



```c++
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

int answer;

int dp[501][501] = {0, };

int recursive(int row, int col, vector<vector<int>>&a)
{
     cout << "row" << row << "col" << col <<endl;
     if(a.size()== row) return 0;
     if (dp[row][col] > 0)
     {
          cout << "dp : " <<"row" << row << "col" << col <<endl;
          return dp[row][col];
     }
     
     return dp[row][col] = a[row][col] + max(recursive(row+1,col,a), recursive(row+1,col+1,a));
}

int solution(vector<vector<int>> triangle) {
     
     answer = -1;
     
     
     
     answer = recursive(0,0,triangle);
     
     return answer;
}

```





-------------------------------------------------------------

가장 큰 수

```c++
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;


bool cmp(string a, string b)
{
     string temp = "";
     temp += a + b;
     
     string temp1 = "";
     temp1 += b + a;
     
     if(temp > temp1){
          return true;
     }
     
     else if(temp1 > temp){
          return false;
     }
     
     else
          return false;
     
}


string solution(vector<int> numbers) {
     string answer = "";
     
     vector<string> strNumbers;
     
     for(int i = 0; i<numbers.size(); i++)
     {
          string temp = "";
          temp = to_string(numbers[i]);
          strNumbers.push_back(temp);
     }
     
     sort(strNumbers.begin(), strNumbers.end(), cmp);
     
     
     for(auto a : strNumbers){
          answer += a;
     }
     
     if(answer.size() == count(answer.begin(),answer.end(), '0'))
          return "0";
     
     return answer;
}

```



```c++
bool cmp(string a, string b)
{
     string temp = "";
     temp += a + b;
     
     string temp1 = "";
     temp1 += b + a;
     
     if(temp > temp1){
          return true;
     }
     
     else if(temp1 > temp){
          return false;
     }
     
     else
          return false;
     
}
```

temp가 더 크다면 true를 리턴.





배운 것. 

1. cmp 함수.

2. count 함수.

3. sort함수

   1. 퀵정렬 기반으로 구현. 퀵정렬은 O(nlogn)

   2. cmp 함수에서 true는 바꾸지마라. false는 바꿔라.

      - ```c++
        bool cmp(int a, int b)
        {
             return a > b;//a가 크다면 true리턴. b가 크다면 false리턴.
          								//들어온 기준이 a, b순이므로 b가 크면 false이므로 b, a순으로 변경.
        }
        
        
        int main()
        {
             int a = 5;
             int b = 6;
             
             cout << cmp(a,b);
             
             return 0;
        }
        ```

      - 위 코드는 false가 출력이 됨.

      - 이유는 간단하게 순서를 a, b순서를 생각하고 a가 b보다 크냐라고 물었을 때, false이므로 바꿔야 한다.

      - 즉, 기준은 a ,b 순서대로 있는 채로 cmp함수에 들어오고 조건문을 준 다음. true,false를 리턴.

4. 

--------------------------------------------------------------------------------------------------------

우테코 지하철 노선도 해보기.





-----------------------------------------------------------

수열, 조합

https://www.acmicpc.net/problem/18809 - 2.4날 일어나서 풀기.

1. C++ stl

- 이진 검색 트리(정렬된 자료구조)
  - set
  - multiset - 중복허용
  - map
- 해시
  - unordered_set
  - unordered_multiset
  - unordered_map
- ETC
  - vector
  - pair
  - tuple
  - stack
  - queue
  - deque



2. JAVA 컬렉션

- Set - 순서가 없음, 데이터 중복 x
  - HashSet
  - TreeSet
- List - 순서가 있음, 데이터 중복 허용
  - LinkedList
  - Vector
  - ArrayList
- Queue - List와 유사
  - LinkedList
  - PriorityQueue
- Map - (key,value), 키 중복 x, value 중복 허용
  - Hashtable
  - HashMap
  - TreeMap



c++ vs java 완전 동일한 것은 아님.

- 해시
  - C++ vs Java
    - vector vs ArrayList
    - unordered_set 
    - unordered_map vs HashMap
    - map vs Map



# 